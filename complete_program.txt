move 0
cpy D0, R6  
lw R0, R6                   // load 11-bit block to registers loop
move 0
cpy D0, R2
add R2, R6
cpy D1, R2
addi R2, 1
cpy D2, R7   				 //R7 equals to R6 + 1
lw R1, R7
lsl R0, 5
cpy D3, R2
lsr R1, 4
cpy D3, R3
lsl R3, 1
cpy D3, R3
xor R2, R3
cpy D3, R2
rxor R2, R4
xor R2, R4
cpy D3, R2                  //DataMem[30+counter] = R2
move 30
cpy D0, R0
add R0, R6
cpy D1, R7
sw R2, R7   
lw R0, R6                   //load value back to R0        
lsr R2, 4
cpy D3, R2
lsl R2, 4
cpy D3, R2
lsr R1, 1
cpy D3, R3
lsl R3, 5
cpy D3, R3
lsr R3, 4
cpy D3, R3
xor R2, R3
cpy D3, R2
rxor R2, R3
lsl R3, 4
cpy D3, R3
lsr R1, 1
cpy D3, R4
move 0
cpy D0, R1
add R1, R4
cpy D1, R0
move 0                      //load the value back to R1
cpy D0, R2
add R2, R6
cpy D1, R2
addi R2, 1
cpy D2, R7   				 //R7 equals to R6 + 1
lw R1, R7
lsl R0, 5
cpy D3, R0
xor R0, R3
cpy D3, R0
lsl R1, 7
cpy D3, R2
lsr R2, 4
cpy D3, R2
xor R0, R2
cpy D3, R4
lw R0, R6                   //load the value back to R0
lsr R0, 1
cpy D3, R2
lsl R2, 6
cpy D3, R2
lsl R1 1
cpy D3, R3
lsr R3, 6
cpy D3, R3
lsl R3, 4
cpy D3, R3
xor R2, R3
cpy D3, R2
lsr R1, 2
cpy D3, R3
lsl R3, 6
cpy D3, R3
lsr R3, 2
cpy D3, R3
xor R2, R3
cpy D3, R2
lsl R1, 7
cpy D3, R3
lsr R1, 6
cpy D3, R3
xor R2, R3
cpy D3, R2
rxor R2, R3
lsl R3, 2
cpy D3, R3
xor R3, R4
cpy D3, R4
lsr R0, 2
cpy D3, R2
lsl R2, 7
cpy D3, R2
lsl R0, 7
cpy D3, R3
lsr R0, 1
cpy D3, R3
xor R2, R3
cpy D3, R2
lsl R1, 1
cpy D3, R3
lsr R1, 7
cpy D3, R3
lsl R3, 5
cpy D3, R3
xor R2, R3
cpy D3, R2
lsr R1, 3
cpy D3, R3
lsl R3, 6
cpy D3, R3
lsr R3, 3
cpy D3, R3
xor R2, R3
cpy D3, R2
lsl R1, 6
cpy D3, R3
lsr R1, 5
cpy D3, R3
xor R2, R3
cpy D3, R2
rxor R2, R3
lsl R3 1
cpy D3, R3
xor R3, R4
cpy D3, R4
rxor R1, R2
rxor R2, R3
xor R2, R3
cpy D3, R2              
move 30                     //load the value stored in memory[30+counter] in R3
cpy D0, R0
add R0, R6
cpy D1, R1
lw R3, R1        
lsl R3, 7
cpy D3, R3
lsr R3, 7
cpy D3, R3
xor R2, R3
cpy D3, R2       
move 0                       //store the value of R4 into R0
cpy D0, R1
add R1, R4
cpy D1, R0        
lsl R0, 3
cpy D3, R3
lsr R3, 7
cpy D3, R3
xor R2, R3
cpy D3, R3
lsl R0, 5
cpy D3, R3
rxor R3, R3
xor R0, R2
cpy D3, R0        
move 31
cpy D0, R1
add R1, R6
cpy D1, R7
sw R0, R7      
move 0                      //increase counter by 2
cpy D0, R0
add R0, R6
cpy D1, R0
addi R0, 2
cpy D2, R6
move 30                     //conditional branch of the loop
cpy D0, R2
move 0
cpy D0, R3
add R3, R6
cpy D3, R1
beqr R2, R3
move 30          //index = 30
cpy D0 R5
lw R0 R5        //R0 = DataMem[index]   //while
move 0
cpy D1 R1
add R1 R5
cpy D1 R1
addi R1 1
cpy D2 R1
lw R2 R1        //R2 = DataMem[index+1]
rxor R0 R3      //R3 = s8
move -30
cpy D0 R1
add R1 R5       //R1 = index-30
cpy D1 R1
lsl R3 3
cpy D3 R3       //R3 = 0000_s8_000
sw R3 R1        //DataMem[index-30] = 0000_s8_000
rxor R2 R7      //R7 = A
rxor R0 R3      //R3 = s8
xor R3 R7       
cpy D3 R3       //R3 = s0
move 0
cpy D0 R1       //R1 = 0
move 1
cpy D1 R0       //offset to the else case
beqr R3 R0      //if R3==0, then go to else
lw R0 R5
lsr R0 4
cpy D3 R3
lsl R3 4
cpy D3 R3
lsr R2 4
cpy D3 R1
xor R1 R3
cpy D3 R3
rxor R3 R3      //R3 = s4
move -30
cpy D0 R1
add R1 R5       //R1 = index-30
cpy D1 R1
lw R0 R1
lsl R3 2
cpy D3 R3
xor R0 R3       
cpy D3 R3 
sw R3 R1        //DataMem[index-30] = 0000_s8_s4_00
lw R0 R5
lsr R0 6
cpy D3 R3
lsl R3 6
cpy D3 R3
lsl R0 4
cpy D3 R1
lsr R1 6
cpy D3 R1
lsl R1 4
cpy D3 R1
xor R1 R3
cpy D3 R3
lsr R2 6
cpy D3 R1
lsl R1 2
cpy D3 R1
xor R1 R3
cpy D3 R3
lsl R1 4
cpy D3 R1
lsr R1 6
cpy D3 R1
xor R1 R3
cpy D3 R3
rxor R3 R3      //R3 = s2
move -30
cpy D0 R1
add R1 R5       //R1 = index-30
cpy D1 R1
lw R0 R1
lsl R3 1
cpy D3 R3
xor R0 R3       
cpy D3 R3 
sw R3 R1        //DataMem[index-30] = 0000_s8_s4_s2_0
lw R0 R5
lsr R0 7
cpy D3 R3
lsl R3 7
cpy D3 R3
lsl R0 2
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 6
cpy D3 R1 
xor R1 R3
cpy D3 R3
lsl R0 4
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 5
cpy D3 R1
xor R1 R3
cpy D3 R3
lsl R0 6
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 4
cpy D3 R1
xor R1 R3
cpy D3 R3
lsr R2 7
cpy D3 R1
lsl R1 3
cpy D3 R1
xor R3 R1
cpy D3 R3
lsl R2 2
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 2
cpy D3 R1
xor R1 R3
cpy D3 R3
lsl R2 4
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 1
cpy D3 R1
xor R1 R3
cpy D3 R3
lsl R2 6
cpy D3 R1
lsr R1 7
cpy D3 R1
xor R1 R3
cpy D3 R3
rxor R3 R3
move -30
cpy D0 R1
add R1 R5       //R1 = index-30
cpy D1 R1
lw R0 R1
xor R0 R3       
cpy D3 R0       //R0 = location = s8_s4_s2_s1;
move 15
cpy D0 R1
move 2      //offset to loc15
cpy D0 R3
beqr R0 R3      //if location==15
move 14
cpy D0 R1
move 3      //offset to loc14
cpy D0 R3
beqr R0 R3      //if location==14
move 13
cpy D0 R1
move 4      //offset to loc13
cpy D0 R3
beqr R0 R3      //if location==13
move 12
cpy D0 R1
move 5      //offset to loc12
cpy D0 R3
beqr R0 R3      //if location==12
move 11
cpy D0 R1
move 6      //offset to loc11
cpy D0 R3
beqr R0 R3      //if location==11
move 10
cpy D0 R1
move 7      //offset to loc10
cpy D0 R3
beqr R0 R3      //if location==10
move 9
cpy D0 R1
move 8        //offset to loc9
cpy D0 R3
beqr R0 R3      //if location==9
move 7
cpy D0 R1
move 9        //offset to loc7
cpy D0 R3
beqr R0 R3      //if location==7
move 6
cpy D0 R1
move 10      //offset to loc6
cpy D0 R3
beqr R0 R3      //if location==6
move 5
cpy D0 R1
move 11         //offset to loc5
cpy D0 R3
beqr R0 R3      //if location==5
move 3
cpy D0 R1
move 12         //offset to loc3
cpy D0 R3
beqr R0 R3      //if location==3
lw R0 R5        //loc15
move 1
cpy D0 R3
lsl R3 7
cpy D3 R3
xor R0 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R0 xor (10000000)
move 13      //offset to end
cpy D0 R3
beqr R1 R3
lw R0 R5        //loc14
move 1
cpy D0 R3
lsl R3 6
cpy D3 R3
xor R0 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R0 xor (01000000)
move 13      //offset to end
cpy D0 R3
beqr R1 R3
lw R0 R5        //loc13
move 1
cpy D0 R3
lsl R3 5
cpy D3 R3
xor R0 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R0 xor (00100000)
move 13      //offset to end
cpy D0 R3
beqr R1 R3
lw R0 R5        //loc12
move 1
cpy D0 R3
lsl R3 4
cpy D3 R3
xor R0 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R0 xor (00010000)
move 13         //offset to end
cpy D0 R3
beqr R1 R3
lw R0 R5        //loc11
move 1
cpy D0 R3
lsl R3 3
cpy D3 R3
xor R0 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R0 xor (00001000)
move 13         //offset to end
cpy D0 R3
beqr R1 R3
lw R0 R5        //loc10
move 1
cpy D0 R3
lsl R3 2
cpy D3 R3
xor R0 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R0 xor (00000100)
move 13        //offset to end
cpy D0 R3
beqr R1 R3
lw R0 R5        //loc9
move 1
cpy D0 R3
lsl R3 1
cpy D3 R3
xor R0 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R0 xor (00000001)
move 13      //offset to end
cpy D0 R3
beqr R1 R3
move 1          //loc7
cpy D0 R3
lsl R3 7
cpy D3 R3
xor R2 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R2 xor (10000000)
move 13      //offset to end
cpy D0 R3
beqr R1 R3
move 1          //loc6
cpy D0 R3
lsl R3 6
cpy D3 R3
xor R2 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R2 xor (01000000)
move 13         //offset to end
cpy D0 R3
beqr R1 R3
move 1          //loc5
cpy D0 R3
lsl R3 5
cpy D3 R3
xor R2 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R2 xor (00100000)
move 13         //offset to end
cpy D0 R3
beqr R1 R3
move 1          //loc3
cpy D0 R3
lsl R3 3
cpy D3 R3
xor R2 R3
cpy D3 R0
sw R0 R5        //DataMem[index] = R2 xor (00100000)
move 1          //end
cpy D0 R1
lsl R1 6
cpy D3 R1 
sw R1 R5
move 15        //offset to shift
cpy D0 R3
beqr R1 R3
lw R0 R5        //else
lsr R0 4
cpy D3 R3
lsl R3 4
cpy D3 R3
lsr R2 4
cpy D3 R1
xor R1 R3
cpy D3 R3
rxor R3 R3      //R3 = s4
move -30
cpy D0 R1
add R1 R5       //R1 = index-30
cpy D1 R1
lw R0 R1
lsl R3 2
cpy D3 R3
xor R0 R3       
cpy D3 R3 
sw R3 R1        //DataMem[index-30] = 0000_s8_s4_00
lw R0 R5
lsr R0 6
cpy D3 R3
lsl R3 6
cpy D3 R3
lsl R0 4
cpy D3 R1
lsr R1 6
cpy D3 R1
lsl R1 4
cpy D3 R1
xor R1 R3
cpy D3 R3
lsr R2 6
cpy D3 R1
lsl R1 2
cpy D3 R1
xor R1 R3
cpy D3 R3
lsl R1 4
cpy D3 R1
lsr R1 6
cpy D3 R1
xor R1 R3
cpy D3 R3
rxor R3 R3      //R3 = s2
move -30
cpy D0 R1
add R1 R5       //R1 = index-30
cpy D1 R1
lw R0 R1
lsl R3 1
cpy D3 R3
xor R0 R3       
cpy D3 R3 
sw R3 R1        //DataMem[index-30] = 0000_s8_s4_s2_0
lw R0 R5
lsr R0 7
cpy D3 R3
lsl R3 7
cpy D3 R3
lsl R0 2
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 6
cpy D3 R1 
xor R1 R3
cpy D3 R3
lsl R0 4
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 5
cpy D3 R1
xor R1 R3
cpy D3 R3
lsl R0 6
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 4
cpy D3 R1
xor R1 R3
cpy D3 R3
lsr R2 7
cpy D3 R1
lsl R1 3
cpy D3 R1
xor R3 R1
cpy D3 R3
lsl R2 2
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 2
cpy D3 R1
xor R1 R3
cpy D3 R3
lsl R2 4
cpy D3 R1
lsr R1 7
cpy D3 R1
lsl R1 1
cpy D3 R1
xor R1 R3
cpy D3 R3
lsl R2 6
cpy D3 R1
lsr R1 7
cpy D3 R1
xor R1 R3
cpy D3 R3
rxor R3 R3
move -30
cpy D0 R1
add R1 R5       //R1 = index-30
cpy D1 R1
lw R0 R1
xor R0 R3       
cpy D3 R0       //R0 = location = s8_s4_s2_s1;
move 0
cpy D0 R1
move 15          //offset to shift
cpy D0 R3
beq R0 R3
move 1          //2_bit
cpy D0 R1
lsl R1 7
cpy D0 R1
move -30
cpy D0 R2
add R2 R5
cpy D1 R2
sw R1 R2
lw R0 R5        //R0 = DataMem[index] //shift
move 0 
cpy D0 R1
add R1 R5
cpy D1 R1
addi R1 1
cpy D2 R1
lw R1 R1        //R1 = DataMem[index+1]
lsr R0 5
cpy D3 R3
move -30
cpy D0 R2
add R2 R5   
cpy D1 R6       //R6 = index-30
lw R2 R6
xor R2 R3
cpy D3 R3
sw R3 R6
lsr R0 1
cpy D3 R3
lsl R3 4
cpy D3 R3
lsr R1 5
cpy D3 R2 
lsl R2 1
cpy D3 R2
xor R3 R2
cpy D3 R3
lsl R1 4
cpy D3 R2
lsr R2 7
cpy D3 R2
xor R3 R2
cpy D3 R3
move 1
cpy D0 R0
add R0 R6
cpy D1 R0
sw R3 R0
move 2
cpy D0 R0 
add R0 R5
cpy D1 R5
cpy D1 R0       //index+=2
move 30
cpy D0 R1
cpy D0 R2
add R1 R2
cpy D1 R1       //R1=60
move 16     //offset to exit
cpy D0 R3
beqr R1 R3      //if index=60, exit
move 17     //offset to while
cpy D0 R3
beqr R1 R3
mov 32          //program3
cpy D0, R7      //R7 = 32
lw R7, R7       //R7 = DataMem[32]       
mov 0           //requirement a
cpy D0, R6      //counter(R6) = 0
cpy D0, R5      //index(R5) = 0
lw R0, R5       //R0 = DataMem[index]   //while1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 19           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift1(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R5(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift1_1
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 20           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift2(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift1_2
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 21           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift3(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift1_3
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 22           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift4(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //indcounterex++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift1_4
cpy D3, R0      //R0 = R0 << 1
mov 0
cpy D0, R2
add R2, R5
cpy D1, R2      //R2 = R5 = index
addi R2, 1      //index++
cpy D3, R5      //R5 = index
cpy D3, R2      //R2 = index
mov 32
cpy D0, R1
mov 23           //offset to store1
cpy D0, R3
beqr R2, R3     //if R2(index)==32, go to store1
mov 18         //offset to go back to while 
cpy D0, R3     
beqr R1, R3     //unconditional jump to while1
mov 31          //store1
cpy D0, R3
mov 2
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 33
sw R6, R3
mov 0           //requirement b
cpy D0, R6      //counter = 0
cpy D0, R5      //index = 0
lw R0, R5       //R0 = DataMem[index]  //while2
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 25           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift1(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R5(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
mov 28          //offset to skip current iteration
cpy D0, R3
beqr R1, R3     //unconditional branch
lsl R0, 1       //shift2_1
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 26           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift2(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
mov 28          //offset to skip current iteration
cpy D0, R3
beqr R1, R3     //unconditional branch
lsl R0, 1       //shift2_2
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 27           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift3(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
mov 28          //offset to skip current iteration
cpy D0, R3
beqr R1, R3     //unconditional branch
lsl R0, 1       //shift2_3
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 28          //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift4(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //indcounterex++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift2_4
cpy D3, R0      //R0 = R0 << 1
mov 0
cpy D0, R2
add R2, R5
cpy D1, R2      //R2 = R5 = index
addi R2, 1      //index++
cpy D3, R5      //R5 = index
cpy D3, R2      //R2 = index
mov 31
cpy D0, R1
addi R1 1
cpy D2 R1
mov 29           //offset to store2
cpy D0, R3
beqr R2, R3     //if R2(index)==32, go to store2
mov 24         //offset to go back to while
cpy D0, R3
beqr R1, R3     //unconditional jump to while2
mov 31          //store 2 
cpy D0, R3
mov 3
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 34
sw R6, R3
mov 0           //requirement c
cpy D0, R6      //counter = 1
cpy R0, R5      //index = 0 
lw R0, R5       //R0 = DataMem[0]
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 30           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift1(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R5(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_1a
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
beqr R2, R3     //if R1(0)==R2, go to shift2(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_2a
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
addi R3, 1       //R3 = 32
cpy D2, R3
beqr R2, R3     //if R1(0)==R2, go to shift3(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_3a
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 631           //offset to skip increment
cpy D0, R3
addi R3, 2
cpy D2, R3      //R3 = 33
beqr R2, R3     //if R1(0)==R2, go to shift4(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //indcounterex++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_4a
cpy D3, R0      //R0 = R0 << 1
mov 1
cpy D0, R5      //R5 = index=1
lw R3, R5       //while3
lsr R3, 4       //R3 >> 4
cpy D3, R3      //R3 = R3 >> 4
add R0, R3      
cpy D0, R0      //R0 = DataMem[index-1][3:0]+DataMem[index][7:4]
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
mov 4
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 35
beqr R2, R3     //if R1(0)==R2, go to shift1(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R5(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_1b
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
mov 5
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 36
beqr R2, R3     //if R1(0)==R2, go to shift2(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_2b
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
mov 6
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 37
beqr R2, R3     //if R1(0)==R2, go to shift3(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_3b
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31          //offset to skip increment
cpy D0, R3
mov 7
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 38
beqr R2, R3     //if R1(0)==R2, go to shift4(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //indcounterex++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_4b
cpy D3, R0      //R0 = R0 << 1        
lw R0, R5       //R0 = DataMem[index]
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
mov 8
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 39
beqr R2, R3     //if R1(0)==R2, go to shift1(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R5(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_1c
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
mov 9
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 40
beqr R2, R3     //if R1(0)==R2, go to shift2(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_2c
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
mov 10
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 41
beqr R2, R3     //if R1(0)==R2, go to shift3(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //counter++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_3c
cpy D3, R0      //R0 = R0 << 1
pm R0, R7
cpy D1, R2      //R2 = R0 pm R7
mov 0
cpy D0, R1      //R1 = 0 
mov 31           //offset to skip increment
cpy D0, R3
mov 11
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 42
beqr R2, R3     //if R1(0)==R2, go to shift4(skip increment)
mov 0
cpy D0, R2
add R2, R6
cpy D1, R2      //R2 == R6(counter)
addi R2, 1      //indcounterex++
cpy D2, R6      //R6 = counter
lsl R0, 1       //shift3_4c
cpy D3, R0      //R0 = R0 << 1
mov 0
cpy D0, R2
add R2, R5
cpy D1, R2      //R2 = R5 = index
addi R2, 1      //index++
cpy D3, R5      //R5 = index
cpy D3, R2      //R2 = index
mov 32
cpy D0, R1
mov 31           //offset to store3
cpy D0, R3
mov 12
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 43
beqr R2, R3     //if R2(index)==32, go to store3
mov 31           //offset to go back to while
cpy D0, R3
mov 3
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 34      
beqr R1, R3     //unconditional jump to while3
mov 31          //store3
cpy D0, R3
mov 4
cpy D0, R4
add R3 R4
cpy D1 R3       //R3 = 35
sw R6, R3